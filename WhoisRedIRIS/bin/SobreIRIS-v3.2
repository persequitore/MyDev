#!/usr/bin/perl

package SobreIRIS;

use IO::Socket;
use POSIX qw{WNOHANG};
use Getopt::Long;
use Net::LDAP;
use NetAddr::IP;
use Net::IP;
use Net::Whois::RIPE;
use Data::Validate::Email;
use Data::Validate::IP;
use Data::Validate::Domain;
use Net::DNS;

use strict;

our($searchError);
use constant VER => "3.0";

my $conffile="/usr/local/bin/SobreIRIS_Conf.pm";
my (%qresult,$result, %been_there, $s);
my $r="";
my $rc=0;
my $addr = <STDIN>;

$addr =~ s/\s|\n//g;

if (length($addr) == 0) {
   print OUTPUT "Error: There wasn't entry string.\n";
}
my $v = 0;
LoadConfig($conffile);


if (($SobreIRIS::UseLocalDB == 0) || ($SobreIRIS::UseLocalDB == 1)) {
   $r = "local LDAP";
   $rc = &queryLocalLDAP($addr, \%qresult, $v);
}  

if ($SobreIRIS::UseLocalDB == 0) {
   $rc = 1;
}

$r = "whois.ripe.net" unless $rc>0;
while (($rc==0) && (! defined $been_there{$r})) {
   $been_there{$r}=1;
   if    ($r eq "whois.ripe.net")   {$rc=queryRIPEStyleDB($r, $addr, \%qresult, \$r, $v)}
   elsif ($r eq "whois.arin.net")   {$rc=queryARIN($addr, \%qresult, \$r, $v)}
   elsif ($r eq "whois.nic.or.kr")  {$rc=queryKRNIC($addr, \%qresult, \$r, $v)}
   elsif ($r eq "whois.apnic.net")  {$rc=queryRIPEStyleDB($r, $addr, \%qresult, \$r, $v)}
   elsif ($r eq "whois.nic.ad.jp")  {$rc=queryJPNIC($addr, \%qresult, \$r, $v)}
   else  {$rc=queryother($r, $addr, \$result, \$r, $v) };
}; 
if ($rc>0) {
   if ($rc==2) { print OUTPUT "\nPrivate or reserved address.\n\nResults obtained from $r.\n\n" }
   else  { print_results(\%qresult, \$r) };
} else { print OUTPUT "Error occured.\n" };


exit(0);

# Load the configuration file
sub LoadConfig {
   my $CONFIG_FILE = shift;
   local *Set = sub { $_[0] = $_[1] unless defined $_[0] };
   require $CONFIG_FILE || die ("Couldn't load SobreIRIS config file '$CONFIG_FILE'\n$@");
}    

# The following code works for RIPE-style DB, which currently resolves to RIPE and APNIC :)
sub whois_query {

# Generic whois client object. No permanent connection, single queries only.
   package WhoisQuery;
   
   sub new {                                                  # new (serverhost, querystring)
      my $this = shift;
      my $class = ref($this) || $this;
      my $self = {};
      my $socket;
      my $querystring = shift || do { return undef };
      $self->{SERVERHOST} = shift || do { print "WhoisQuery needs a server to connect to.\n"; return undef };
      $self->{SERVERPORT} = shift || 43;
      $self->{QUERYRESULT} = [];
      
      bless $self, $class;
      $socket = IO::Socket::INET->new(PeerAddr => $self->{SERVERHOST},
      PeerPort => "43",
      Timeout  => "20",
      Proto    => "tcp") || do { return undef };
      print $socket "$querystring\n";
      @{ $self->{QUERYRESULT} } = <$socket>;
      close $socket;
      return $self;
   } 
   
   sub result {
      my $self = shift;
      return @{ $self->{QUERYRESULT} };
   }
}

sub queryRIPEStyleDB
{
   my ($server, $querystring, $queryresult, $redir, $verbose) = @_;
   my %techcs      = ();
   my %irts        = ();
   my $emptylines  = 0;
   my $returncode  = 1;
   
   # Connect to server

   print "Querying RIPE db at $server.\n"  if $verbose;
   my $socket = IO::Socket::INET->new(PeerAddr => "$server",
                                      PeerPort => "43",
                                      Proto    => "tcp") || do {
      print "Could not connect to $server: $!" if $verbose;
      return -1;
   };
   print "    $querystring... " if $verbose;

   # Ask for permanent connection (send "-k\n").

   print $socket "-k\n";
   while (<$socket>) {
      if (/^$/) { $emptylines++ } else { $emptylines=0 };
      last if $emptylines==2;
   }
   
   # Send query string, check sanity of server output, grep contacts.

   print $socket "-r $querystring\n";
   while (<$socket>) {
      /^netname:\s*IANA-.BLK-RESERVED/ && do {
           close $socket;
           print "reserved\n" if $verbose;
           return 2;
      };
      /^netname:\s*IANA-BLK$/ && do {
         close $socket;
         print "not in RIPE\n" if $verbose;
         $$redir="whois.arin.net";
         return 0;
      };
      /^tech-c:\s*(.*)/ && do { $techcs{$1}=1 };
      /^mnt-irt:\s*(.*)/ && do { $irts{$1}=1 };
      $queryresult->{'output'} .= $_;
      if (/^$/) { $emptylines++ } else { $emptylines=0 };
      /\b(whois\.\S+\.[a-z]+)\b/i && do { 
         if (! ($1 eq $server)) { 
            print "found a reference to $1\n" if $verbose;
            $$redir=$1;
            $returncode=0;
         } 
      };
      last if $emptylines==2;
   }
   print "ok.\n" if $verbose;
  # If irt pointer not found yet, query for it implicitely ("-c"). APNIC will ignore this for now.
   
   if (keys(%irts)==0) {
      print "    -c $querystring... " if $verbose;
      print $socket "-rc $querystring\n";
      $emptylines=0;
      while (<$socket>) {
         /^mnt-irt:\s*(.*)/ && do { $irts{$1}=1 };
         $queryresult->{'output'} .= $_ unless (!($_ =~ /% Information related/) && (($_ =~ /^%/) || ($_ =~ /^$/)));
         if (/^$/) { $emptylines++ } else { $emptylines=0 };
         last if $emptylines==2;
      }
      $queryresult->{'output'} .="\n";
      if ($verbose) { if (keys(%irts)>0) { print "successful\n" } else { print "failed\n" }  };
   }
   
   # Query for person objects from tech-c fields.
   
   while (my ($k, $v) = each(%techcs)) {
      print "    $k... " if $verbose;
      print $socket "-r $k\n";
      $emptylines=0;
      while (<$socket>) {
         $queryresult->{'output'} .= $_ unless (!($_ =~ /% Information related/) && (($_ =~ /^%/) || ($_ =~ /^$/)));
         if (/^$/) { $emptylines++ } else { $emptylines=0 };
         last if $emptylines==2;
      }
      print "ok.\n" if $verbose;
   }
   $queryresult->{'output'} .="\n";
   
   while (my ($k, $v) = each(%irts)) {
      print "    $k... " if $verbose;
      print $socket "-r $k\n";
      $emptylines=0;
      while (<$socket>) {
         $queryresult->{'output'} .= $_ unless (!($_ =~ /% Information related/) && (($_ =~ /^%/) || ($_ =~ /^$/)));
         if (/^$/) { $emptylines++ } else { $emptylines=0 };
         last if $emptylines==2;
      }
      print "ok.\n" if $verbose;
   }
   $queryresult->{'output'} .="\n";
   
   close $socket;
   return $returncode;
}  
   
# In ARIN, we look for TechEmail and AbuseEmail fields. Optionally, we may be redircted to
# one or more more specific subnet records, so we need to take care of that as well.

sub queryARIN {
   my ($querystring, $queryresult, $redir, $verbose) = @_;
   my $server      = "whois.arin.net";
   my %netblk      = ();
   my $innetblk    = 0;
   my $netblkname  = "";
   
   print "Querying ARIN db at $server.\n    $querystring... "  if $verbose;
   (my $q = WhoisQuery->new($querystring,$server)) || return -1;
   my @res = $q->result();
   for (@res) {
      # We got refence to netblock record(s). Deobfuscate them to get the query phrase.
      /\((NET(BLK)?-(\S*))\)/ && do {$innetblk=1; $netblkname=$1};
      if (($innetblk>0) && /((\d{1,3}\.){3}\d{1,3})\s*-\s*((\d{1,3}\.){3}\d{1,3})/) {
         $netblk{$netblkname}=1;
         $innetblk=0;
      };
      # Sorry, but I know someone who may know ...
      /^ReferralServer: whois:\/\/(.*)/ && do {
         $$redir=$1;
         print "-> $1\n" if $verbose;
         return 0;
      };
      /^NetHandle:\s*(.*)/ && do { $netblk{$1}=1 };
      # IANA reservations are indicated here. This seems to be the only way to check them.
      /^NetType:\s*IANA (Reserved|Special Use)/ && do {
         print "reserved.\n" if $verbose;
         return 2
      };
   };
   for my $net (keys %netblk) {
      ($q = WhoisQuery->new($net,$server)) || return -1;
      @res = $q->result();
      foreach (@res) {
         $queryresult->{'output'} .= $_;
      };
   };
   print "ok.\n" if $verbose;
   return 1;
}  

# KRNIC has a very non-standardized structure. We dig for E-Mail fields in Tech.Contact Info and
# ISP Network Abuse Contact Info areas. Different areas are separated by blank lines and banners.

sub queryKRNIC {
   my ($querystring, $queryresult, $redir, $verbose) = @_;
   my $server      = "whois.nic.or.kr";
   my %countries   = ();
   my $contacttype = 0;   # 1 for techs, 2 for abuse

   print "Querying KRNIC db at $server.\n    $querystring... "  if $verbose;
   (my $q = WhoisQuery->new($querystring,$server)) || return -1;
   my @res = $q->result();
   foreach (@res) {
      $queryresult->{'output'} .= $_;
   }; 
   print "ok.\n" if $verbose;
   return 1;
}  
   
# In JPNIC we look for "abuse" keyword, [E-Mail] field or references to techs in [Technical Contact]
# Unfortunately, JPNIC does not mention support for permanent connections and we need to send a new
# query each time.

sub queryJPNIC {  
   my ($querystring, $queryresult, $redir, $verbose) = @_;
   my $server      = "whois.nic.ad.jp";
   my %techcs      = ();

   print "Querying JPNIC db at $server.\n    $querystring... "  if $verbose;
   (my $q = WhoisQuery->new("$querystring\/e",$server)) || return -1;
   
   my @res = $q->result();
   foreach (@res) {
      /^n\.\s*\[Technical Contact\]\s*(.*)$/ && do { $techcs{$1}=1 };
      $queryresult->{'output'} .= $_;
   }
   for my $k (keys %techcs) {
      $q = WhoisQuery->new("$k\/e", $server) || return -1;
      @res = $q->result();
      foreach (@res) {
         $queryresult->{'output'} .= $_;		   
      }
   }
   
   return 1;
}  
   
sub queryother
{
   my ($server, $querystring, $queryresult, $redir, $verbose) = @_;
   
   $server =~ /\.jp$/ && do {$querystring.="/e"};
   print "Querying whois db at $server.\n    $querystring... " if $verbose; 
   (my $q = WhoisQuery->new($querystring,$server)) || return -1;
   my @res = $q->result();
   foreach (@res) {
      /(whois\.[\w|\.]+\.[a-z]+)/i && (!(lc($1) =~ /$server/i)) && do {
         $$redir=lc($1);
         print "-> ".$$redir."\n" if $verbose;
         return 0;
      }; 	
      $queryresult->{'output'} .= $_
   }
   print "ok.\n" if $verbose;
   return 1;
}  

# Function to connect to the LDAP server
sub connectLDAP {
   my $server = shift;
   my $port = shift;
   
   my $ldap = Net::LDAP->new( $server,
                              port => $port,
                              timeour => 10,
                              async => 1
                              );
   return $ldap;

}

# Disconnect from LDAP
sub disconnectLDAP {
   my $ldap = shift;
   
   $ldap->unbind();
}

# Bind LDAP

sub bindLDAP {
   my $ldap = shift;
   my $binddn = shift;
   my $password = shift;
   $ldap->bind($binddn, password => $password);
   #$ldap->bind();
}

# Perfom a search in LDAP
sub searchLDAP {
   my $ldap = shift;
   my $filter = shift;
   my $base = shift;
   my $scope = shift;
   
   my $mesg = $ldap->search ( # perform a new search
      base => $base,
      filter => $filter,
      scope => $scope
      );
   if ($mesg->error eq "Success") {
      $searchError = 'Success';
      if (scalar ($mesg->all_entries) > 0) {
         my @aux = $mesg->all_entries;
         return \@aux;
      } else {
         return undef;
      }
   } else {
      $searchError = 'Code: '.$mesg->code.' Info: '.$mesg->error;
      return undef;
   }
}

# Check is an IP or Hostname
sub isIPHostname {
   my ($querystring) = @_;
        
   my $ip = Data::Validate::IP->new();
   if ($ip->is_ipv4($querystring)) {
      my $res= Net::DNS::Resolver->new;
      my $query = $res->search($querystring);
      my %infoIP;
      $infoIP{'ip'} = $querystring;
      if ($query) {
         foreach my $rr ($query->answer) {
            if ($rr->type eq "PTR") {
               $infoIP{'hostname'} = $rr->ptrdname;
            }
         }
      } 
      return \%infoIP;
   } else {
      my $res = Net::DNS::Resolver->new;
      my $query = $res->search($querystring);
      if ($query) {
         foreach my $rr ($query->answer) {
            if ($rr->type eq "A") {
               my %infoIP;
               $infoIP{'ip'} = $rr->address;
               $infoIP{'hostname'} = $querystring;
               return \%infoIP;
            }
         }
      }
   }
   # This means that it's not an IP or an hostname.
   return undef;
}  
   
# Check if it's a domain
sub isDomain {
   my ($querystring) = @_;
   
   my $v = Data::Validate::Domain->new();
   if ($v->is_domain($querystring)) {
      my $res = Net::DNS::Resolver->new;
      my $query = $res->query($querystring, "SOA");
      if ($query) {
         return 1;
      }
   }
   return 0;
}  
   
# Check if it's a mail address
sub isMailAddress {
   my ($querystring) = @_;
   
   my $v = Data::Validate::Email->new();
   if ($v->is_email($querystring)) {
      return 1;
   }
   return 0;
}  

sub moreSpecific {
   my $entries = shift;
   my $rightEntry = shift;
   my $range = undef;
   my $cidr = shift;
   foreach my $entry (@$entries) {
      my $tempEntry = $entry;
      my $diff = $entry->get_value('irisLastIp') - $entry->get_value('irisFirstIp');
      if (defined $range) {
         if ($diff < $range) {
            $$rightEntry = $entry;
            $range = $diff;
            $$cidr = $entry->get_value('irisCIDR');
         }
      } else {
         $$rightEntry = $entry;
         $range = $diff;
         $$cidr = $entry->get_value('irisCIDR');
      }
   }
}  

sub doQueryLDAP {
   my $ldap = shift;
   my $baseDN = shift;
   my $filter = shift;
   my $scope = shift;
   my $verbose = shift;
   
   my @totalEntries;
   my $noEntries = 1;
   # Get the matched entries
   foreach my $basedntemp (@$baseDN) {
      my $entries  = &searchLDAP ($ldap,$filter,$basedntemp,$scope);
      if (($searchError eq "Success") && (defined $entries)) {
         foreach my $entry (@$entries) {
            push @totalEntries,$entry;
         }
         $noEntries = 0;
      } else {
         print "Error -> ",$searchError,"\n" if $verbose;
      }
   }   
   if ($noEntries) {
      return undef;
   }
   
   return \@totalEntries;
}
# Query LDAP Server
sub queryLocalLDAP {
   my ($querystring, $output, $verbose) = @_;

   my @queryLDAP = @{$SobreIRIS::LDAPInfo};
   my %queryLDAP = ();
   for (my $i = 0; $i < scalar(@queryLDAP); $i = $i+2) {
      $queryLDAP{$queryLDAP[$i]} = $queryLDAP[$i+1];
   }

   my $sldap = connectLDAP($queryLDAP{'Host'},$queryLDAP{'Port'});
   if (defined $sldap) {
      $sldap->bind($queryLDAP{'BindDN'},password => $queryLDAP{'BindPassword'});
      my $ipHost;
      my $filter;
      my @baseDN;
      my $type;
      my $scope;
      # Check the input to make the filter, and the search
      if (($ipHost = &isIPHostname ($querystring)) != undef) {
         $filter = $queryLDAP{'Filter-IP'};
         my $ip = new NetAddr::IP($ipHost->{'ip'});
         my $numip = $ip->numeric();
         $filter =~ s/VALUE_DATA/$numip/g;
         push @baseDN , $queryLDAP{'BaseDN-IP'};
         $scope = "sub";
         my $entries = doQueryLDAP($sldap,\@baseDN,$filter,$scope,$verbose);
         if (defined $entries) {
            my $entry;
            my $CIDR;
            my @entryOut;
            &moreSpecific($entries,\$entry,\$CIDR);
            push @entryOut,$entry;
	    my $DN = $entry->get_value('irisWhoisNetName');
	    my $InstFilter = '(schacPersonalUniqueCode=urn:mace:terena.org:schac:personalUniqueCode:es:'.$entry->get_value('irisWhoisNetName').')';
	    #$DN = 'dc='.$DN.',dc=instituciones,dc=rediris,dc=es';
            my $resultEntries = &searchLDAP($sldap,$InstFilter,"dc=com,dc=rediris,dc=es",'sub');
            $$output{'ip'} = $ipHost->{'ip'};
            $$output{'hostname'} = $ipHost->{'hostname'};
            my $notfound = 1;
            if (($searchError eq "Success") && (defined $resultEntries)) {                 
               foreach (@$resultEntries) {
                  push @entryOut,$_;
		  # Metemos las personas
		  my $ref = $_->get_value("schacPersonalUniqueID", asref => 1);
	          my $instID = undef;
	          foreach my $valore (@{$ref} ) {
			  if ($valore =~ m/copa/i) {
				  $valore =~ m/urn:mace:terena.org:schac:personalUniqueID:es:copa:(.*)/;
				  $instID = $1;
			  }
		  }
		  if (defined $instID) {
			  my $filtero = '(schacUserStatus=urn:mace:terena.org:schac:userStatus:es:rediris.es:affiliation:organization:'.$instID.')';
			  my $nmesg = $sldap->search(
				  base => "dc=rotw,dc=rediris,dc=es",
				  filter => $filtero,
				  scope => 'one');
			  foreach  my $nentry ($nmesg->entries) { push @entryOut,$nentry; }
		   }
               }
               $notfound = 0;
            } else {
               print "Error ->", $searchError,"\n" if $verbose;
            }
	  
	    $DN = $entry->get_value('irisWhoisNetName');
	   my $nsldap = connectLDAP("magnesio.rediris.es","1389");
	   if (defined $nsldap) {
		         $nsldap->bind('uid=manager,dc=rediris,dc=es',password => 'ldap-r3d1r1s');

            		$resultEntries = &searchLDAP($nsldap,'(o='.$DN.')','dc=cert,dc=coord,dc=rediris,dc=es','sub');
            		if (($searchError eq "Success") && (defined $resultEntries)) {
               			foreach (@$resultEntries) {
                  			push @entryOut,$_;
               			}
               			$notfound = 0;
            		} else {
               			print "Error ->", $searchError,"\n" if $verbose;
            		}
            		if ($notfound) {
               			return 0;
            		}
		}
            $$output{'type'} = "IPHostname";
            $$output{'entries'} = \@entryOut;
	
       	} else {
            return 0;
         }
      } elsif (&isDomain($querystring)) {
         $filter = $queryLDAP{'Filter-Domain'};
         $filter =~ s/VALUE_DATA/$querystring/g;
         @baseDN = split /::/,$queryLDAP{'BaseDN-Domain'};
         $type = "Domain";
         $scope = "one";
         my $entries = doQueryLDAP($sldap,\@baseDN,$filter,$scope,$verbose);
         if (defined $entries) {
            # Just in case we get more than one domain
            my @entryOut;
            $$output{'domain'} = $querystring;
            $$output{'type'} = "Domain";
            my $notfound = 1;
            foreach my $singleDomain (@$entries) {
               my $resultEntries = &searchLDAP($sldap,'(|(objectClass=irisPerson)(objectClass=dcObject)(objectClass=inetOrgPerson)(objectClass=irisIPRange))',$singleDomain->dn(),'sub');
               if (($searchError eq "Success") && (defined $resultEntries)) {
                  foreach (@$resultEntries) {
                     push @entryOut,$_;1
                  }
                  $notfound = 0;
               } else {
                  print "Error ->", $searchError,"\n" if $verbose;
               }

               my $contactDn = $singleDomain->dn();
               $contactDn=~ /dc=(.*),dc=.*,dc=.*,dc=.*/;
               $resultEntries = &searchLDAP($sldap,'(o='.$1.')','dc=coord,dc=rediris,dc=es','sub');
               if (($searchError eq "Success") && (defined $resultEntries)) {
                  foreach (@$resultEntries) {
                     push @entryOut,$_;
                  }
               } else {
                  print "Error ->", $searchError,"\n" if $verbose;
               }
            }
            if ($notfound) {
               return 0;
            }
            $$output{'entries'} = \@entryOut;  
         } else {
            return 0;
         }
      } elsif (&isMailAddress($querystring)) {
         $filter = $queryLDAP{'Filter-Mail'};
         $filter =~ s/VALUE_DATA/$querystring/g;
         @baseDN = split /::/,$queryLDAP{'BaseDN-Mail'};
         my $entries = doQueryLDAP($sldap,\@baseDN,$filter,'sub',$verbose);
         if (defined $entries) {
            # Just in case we get more than one domain
            $$output{'mail'} = $querystring;
            $$output{'type'} = "Mail";
            $$output{'entries'} = $entries;
         } else {
            return 0;
         }
      } else {
         $filter = $queryLDAP{'Filter-All'};
         $filter =~ s/VALUE_DATA/$querystring/g;
         @baseDN = split /::/,$queryLDAP{'BaseDN-All'};
         my $entries = doQueryLDAP($sldap,\@baseDN,$filter,'sub',$verbose);
         if ($entries) {
            $$output{'general'} = $querystring;
            $$output{'type'} = "All";
            $$output{'entries'} = $entries;
         } else {
            return 0;
         }
      }

   } else {
      print "Error: Connection refused to LDAP" if $verbose;
      return 0;
   }      
   return 1;
}

# Get an entry which is process at a string.
sub e2sPerson {
   my $entry = shift;
   my %atributos = (
                    "cn"                            => "Nombre y Apellidos",
                    "businessCategory"              => "Tipo de Contacto",
                    "title"                         => "Titulo",
                    "mail"                          => "Dirección de Correo",
                    "telephoneNumber"               => "Telefono",
                    "facsimileTelephoneNumber"      => "FAX",
		    "description"		    => "Tipo de Contacto",
		    "schacUserStatus"		    => "Tipo de Contacto",
                    );
   my $string = "% Information related to ";
   $string .= $entry->dn() . "\n\n";
   foreach my $attr (keys %atributos) {
      if ($entry->exists($attr)) {
	 if ($attr eq 'schacUserStatus') {
		my @values = @{$entry->get_value($attr, asref => 1)};
		foreach my $value (@values) {
			if ($value =~ /affiliation\:role\:/) {
				$value =~ m/urn:mace:terena.org:schac:userStatus:es:rediris.es:affiliation:role:(.*)/;
				$string .= "% Tipo de Contacto:\t $1\n";
			}
		}	
	 } else {
             $string .= "% ".$atributos{$attr}.":\t";
             $string .= join " - ",@{$entry->get_value($attr, asref => 1)};
             $string .= "\n";
	 }
      }
   }
   $string .= "\n";
   return $string;
}  
   
# Get an entry which is process at a string.
sub e2sInstitucion {
   my $entry = shift;
   my %atributos = (
                    "o"                             => "Organización",
                    "associatedDomain"              => "Dominio",
                    "telephoneNumber"               => "Telefono",
                    "facsimileTelephoneNumber"      => "FAX",
                    "postalAddress"                 => "Dirección",
                    "postalCode"                    => "Código Postal",
                    "l"                             => "Ciudad",
                    "st"                            => "Provincia"
                    );
   my $string = "% Information related to ";
   $string .= $entry->dn() . "\n\n";
   foreach my $attr (keys %atributos) {
      if ($entry->exists($attr)) {
         $string .= "% ".$atributos{$attr}.":\t\t";
         $string .= join " - ",@{$entry->get_value($attr, asref => 1)};
         $string .= "\n";
      }
   }
   $string .= "\n";
   return $string;
}  
   
# Get an entry which is process at a string.
sub e2sIPRange {
   my $entry = shift;
   my %atributos = (
                    "irisWhoisCIDR"      => "Rango IP",
                    "irisWhoisNetName"   => "Nombre de la red",
                    "irisWhoisASN"       => "ASN",
                "irisWhoisRouter"    => "Router"
                    );
   my $string = "% Information related to ";
   $string .= $entry->dn() . "\n\n";
   foreach my $attr (keys %atributos) {
      if ($entry->exists($attr)) {
         $string .= "% ".$atributos{$attr}.":\t";
         $string .= join " - ",@{$entry->get_value($attr, asref => 1)};
         $string .= "\n";
      }
   }
   $string .= "\n";
   return $string;
}     
   
sub typeEntry {
   my $entry = shift;
        
   my $ref = $entry->get_value ( 'objectClass', asref => 1 );
   my $values = join "::",@$ref;
   $values = "::".$values."::";
   my $type = undef;
   if ($values =~ /::organization::/) {
      $type = "Institucion";
   } elsif  (($values =~ /::irisPerson::/)|| ($values =~ /::eduPerson::/))  {
      $type = "Persona";
   } elsif ($values =~ /::irisWhoisIpRange::/) {
      $type = "IPRango";
   }
   return $type;
}  

sub orderQuery {
   my $entries = shift;
   my $orderedEntries = shift;
   my @institucionEntries;
   my @iprangeEntries;
   my @contactEntries;
   
   foreach my $entry (@$entries) {
      my $type = &typeEntry($entry);
      if ($type eq "Institucion") {
         push @institucionEntries, $entry;
      } elsif ($type eq "Persona") {
         push @contactEntries, $entry;
      } elsif ($type eq "IPRango") {
         push @iprangeEntries,$entry;
      }
   }
   $$orderedEntries{'instituciones'} = \@institucionEntries;
   $$orderedEntries{'rangos'} = \@iprangeEntries;
   $$orderedEntries{'personas'} = \@contactEntries;
}  
sub print_results {

   my ($output, $r) = @_;
   
   print STDOUT "% Results obtained from $$r.\n\n";
   if ( $$r eq "local LDAP" ) {
      if (exists $$output{'entries'}) {
         print STDOUT "%-----------------------------------------------------\n";
         print STDOUT "%\t\t UNA DE LAS NUESTRAS -CUIDADINES-\n";
         print STDOUT "%-----------------------------------------------------\n";
         if ($$output{'type'} eq "IPHostname") {
            print STDOUT  "% La cadena buscada fue: ".$$output{'ip'}." - ".$$output{'hostname'}."\n";
         } elsif ($$output{'type'} eq "Domain") {
            print STDOUT  "% La cadena buscada fue: ".$$output{'domain'}."\n";
         } elsif ($$output{'type'} eq "Mail") {
            print STDOUT  "% La cadena buscada fue: ".$$output{'mail'}."\n";
         } elsif ($$output{'type'} eq "All") {
            print STDOUT  "% La cadena buscada fue: ".$$output{'general'}."\n";
         }
         
         my $entries = $$output{'entries'};
         my %orderedOutEntries;
         &orderQuery ($entries,\%orderedOutEntries);
         
         my $outString;
         my @tempOut = @{$orderedOutEntries{'instituciones'}};
         foreach (@tempOut) {
            $outString .= &e2sInstitucion($_);
         }
         
         @tempOut = @{$orderedOutEntries{'rangos'}};
         
         foreach (@tempOut) {
            $outString .= &e2sIPRange($_);
         }
         
         @tempOut = @{$orderedOutEntries{'personas'}};
         foreach (@tempOut) {
            $outString .= &e2sPerson($_);
         }
         print STDOUT $outString;
      } else {
         print STDOUT "%-----------------------------------------------------\n";
         print STDOUT "%\t\t UNA DE LAS NUESTRAS -CUIDADINES-\n";
         print STDOUT "%\t\t NO TENIA INFORMACION DE CONTACTO AVISAR A MARIA\n";
         print STDOUT "%-----------------------------------------------------\n";
      }			 
   } else {
      my $string= $$output{'output'};
      print STDOUT $string;
      print STDOUT "\n";
   }
   
}  

